snippet llr "braket" iA
($1)
endsnippet

snippet kr "braket" iA
[$1]
endsnippet

snippet stt "string" iA
"$1"
endsnippet

snippet main "template" bA
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
using P = pair<int,int>;

int main(){
	$0
}
endsnippet

snippet cout "cout" bA
cout << $1 << endl;
endsnippet

snippet cin "cin" bA
cin >> $1;
endsnippet

snippet if "if" bA
if ($1) {
	$2
} $0
endsnippet

priority 10
snippet eif "else if" iA
else if ($1) {
	$2
} $0
endsnippet

priority 1
snippet else "else" iA
else {
	$1
}
endsnippet

snippet for "for" bA
for (int ${1:i} = 0; $1 < ${2:n}; $1++){
	$3
}
endsnippet

priority 10
snippet dfor "dfor" bA
for (auto ${1:v} : $2){
	$3
}
endsnippet

snippet while "while" bA
while ($1) {
	$2
}
endsnippet

priority 1
snippet int "int" bA
int $1;
endsnippet

snippet funcint "funcint" bA
int ${1:f}($2){
	$3
}
endsnippet

snippet db "double" bA
double $1;
endsnippet

snippet ll "ll" bA
ll $1;
endsnippet

snippet bool "bool" bA
bool $1;
endsnippet

snippet vec "vector" bA
vector<${1:int}> ${2:name}(${3:n});
endsnippet

priority 10
snippet dvec "dvector" bA
vector<vector<${1:int}>> ${2:name}(${3:h},vector<$1>(${4:w}));
endsnippet

priority 1
snippet fin "fileopen" bA
FILE *fp;
char buf[BUF_SIZE];

if ((fp = fopen("${1:filename}", "r")) == NULL) {
	printf("Cannot open file (%s) \n", "$1"); return 1;
}
/* r :for reading, w :for writing, */

/* Read the file */
fgets(buf, BUF_SIZE, fp);

/* example */
//sscanf(buf, "%d", &n);

/* Read the file */
//while (fgets(buf, BUF_SIZE, fp) != NULL) {
//	int a, b, c;
//	sscanf(buf, "%d %d %d", &a, &b, &c);
//}
fclose(fp);
endsnippet

snippet pf "printf" bA
printf("$1\n",$2);
endsnippet
 
priority 10
snippet fpf "fprintf" bA
fprintf(gp,"$1\n");
endsnippet

snippet spf "sprintf" bA
sprintf(str,"");
endsnippet

priority 1
snippet gp "gnuplot" bA
FILE *gp;
gp=popen("gnuplot -persist","w");
$1
fflush(gp);
fprintf(gp,"quit\n");
pclose(gp);
endsnippet

snippet att "at" iA
.at($1)
endsnippet

snippet atcoder "atcoder" bA
#include <atcoder/all>
using namespace atcoder;
endsnippet

snippet PC "physics constant" bA
const double pi = atan(1)*4.0 ;
const double e = 1.602176634e-19 ; /*elementary charge (C) */
const double G = 6.67430e-11 ; /*Newtonian constant of grabitation (m^3*kg^-1*s^-2) */
const double h = 6.62607015e-34 ; /*Planck constant (J*Hz^-1) */
const double hbq = h/(2*pi) ; /*Dirac constant (J*Hz^-1) */
const double c = 299792458 ; /*spped of light in vacuum (m*s^-1) */
const double e0 = 8.8541878128e-12 ; /*vacuum electric permittivity (F*m^-1) */
const double mu0 = 1.25663706212e-6 ; /*vacuum magnetic permeability (N*A^-2) */
const double me = 9.1093837015-31 ; /*electron mass (kg) */
const double alpha = 7.2973525693e-3 ; /*fine-structure constant () */
const double kb = 1.380649e-23 ; /*Boltzmann constant(J*K^-1) */

endsnippet


snippet '([fs]?printf.*)(ff)' "printff" wrA
`!p snip.rv = match.group(1)`%f
endsnippet

snippet '([fs]?printf.*)(dd)' "printfd" wrA
`!p snip.rv = match.group(1)`%d
endsnippet

snippet '([fs]?printf.*)(ee)' "printfe" wrA
`!p snip.rv = match.group(1)`%e
endsnippet

snippet sort "sort" bA
sort($1.begin(),$1.end());
endsnippet

snippet reverse "reverse" bA
reverse($1.begin(),$1.end());
endsnippet


snippet and "and" i
 && 
endsnippet

snippet or "or" i
 || 
endsnippet

#AtCoderでよく使うライブラリ
snippet map "map" bA
map<${1:int},${2:int}>${3:mp};
endsnippet

snippet queue "queue" bA
queue<${1:int}> ${2:q};
endsnippet

snippet stack "stack" bA
stack<${1:int}> ${2:st};
endsnippet

snippet pqueue "priority_queue" bA
//値が大きい順に取り出される。小さい順にしたかったら
//priority_queue<型, vector<型>, greater<型>> 変数名;
priority_queue<${1:int}> ${2:pq};
endsnippet

snippet set "set" bA
set<${1:int}> ${2:st};
endsnippet

snippet nCr "nCr" bA
/*ACLのmathを使うから以下が必要
#include <atcoder/all>
using namespace atcoder;*/

unsigned int Cmod = 1000000007;
unsigned int fact[200009];
unsigned int factinv[200009];

void init() {
	fact[0] = 1;
	internal::barrett bt(Cmod);
	for (unsigned int i = 1; i <= 200000; i++) fact[i] = (bt.mul(bt.mul((unsigned int)1,i),fact[i - 1]));
	for (int i = 0; i <= 200000; i++) factinv[i] = inv_mod((long long)fact[i],(long long)Cmod);
}
unsigned int ncr(int n, int r) {
	internal::barrett bt(Cmod); 
	if (n < r || r < 0) return 0;
	return bt.mul(bt.mul(fact[n],factinv[r]),factinv[n-r]);
}
endsnippet

snippet prime_factorize "prime_factorize" bA
/*ACLのmathを使うから以下が必要
#include <atcoder/all>
using namespace atcoder;*/

constexpr long long pow_mod_long_constexpr(long long x, long long n, long long m) {
    if (m == 1) return 0;
    unsigned long long _m = (unsigned long long)m;
    __int128_t r = 1;
    __int128_t y = internal::safe_mod(x, m);
    while (n) {
        if (n & 1) r = (r * y) % _m;
        y = (y * y) % _m;
        n >>= 1;
    }
    return (long long)r;
}

constexpr bool is_prime_long_constexpr(long long n) {
    if (n <= 1) return false;
    if (n == 2 || n == 7 || n == 61) return true;
    if (n == 325 || n == 9375 || n == 28178 || n == 450775 || n == 9780504 || n == 1795265022) return false;
    if (n % 2 == 0) return false;
    long long d = n - 1;
    while (d % 2 == 0) d /= 2;
    constexpr long long bases[7] = {2, 325, 9375, 28178, 450775, 9780504, 1795265022};
    for (long long a : bases) {
	if (internal::inv_gcd(n,a).first == n) continue;
        long long t = d;
        __int128_t y = pow_mod_long_constexpr(a, t, n);
        while (t != n - 1 && y != 1 && y != n - 1) {
            y = y * y % n;
            t <<= 1;
        }
        if (y != n - 1 && t % 2 == 0) {
            return false;
        }
    }
    return true;
}

long long pollard(long long N) {
    if (N % 2 == 0) return 2;
    if (is_prime_long_constexpr(N)) return N;

    auto f = [&](long long x) -> long long {
        return (__int128_t(x) * x + 1) % N;
    };
    long long step = 0;
    while (true) {
        ++step;
        long long x = step, y = f(x);
        while (true) {
            long long p = internal::inv_gcd(y - x + N, N).first;
            if (p == 0 || p == N) break;
            if (p != 1) return p;
            x = f(x);
            y = f(f(y));
        }
    }
}

//素因数分解を高速に求める(O(N^1/4))
vector<long long> prime_factorize(long long N) {
    if (N == 1) return {};
    long long p = pollard(N);
    if (p == N) return {p};
    vector<long long> left = prime_factorize(p);
    vector<long long> right = prime_factorize(N / p);
    left.insert(left.end(), right.begin(), right.end());
    sort(left.begin(), left.end());
    return left;
}
void dfsd(long long cur_idx, long long cur_val, vector<long long> &Y, vector<pair<long long,long long>> &mp){
	long long N = mp.size();
	if (cur_idx == N) {
		Y.push_back(cur_val);return;
	}
	long long v = mp[cur_idx].first;
	long long c = mp[cur_idx].second;
	long long mul = 1;
	for (int p = 0; p < c+1; p++){
		dfsd(cur_idx+1, cur_val*mul, Y, mp);
		mul *= v;
	}
	return;
}

//約数列挙を高速に求める
//Yが約数列挙でVが素因数分解のしたpair型
pair<vector<long long>,vector<pair<long long,long long>>> calc_devisor_fast(long long N){
	vector<long long> Y;
	auto a = prime_factorize(N);
	vector<pair<long long, long long>> V;
	long long count = 1;
	for (long long i = 0; i < a.size(); i++){
		if (i != a.size()-1) {
			if (a[i] != a[i+1]){
				V.push_back(make_pair(a[i],count));
				count = 1;
			}
			else{
				count++;
			}
		}
		else{
			V.push_back(make_pair(a[i],count));
		}
	}
	dfsd(0, 1, Y, V);
	sort(Y.begin(),Y.end());
	return {Y,V};
}
endsnippet

snippet lam "lamba_function" bA
auto ${1:f} = []($2){
	$3
};
endsnippet

snippet pv "print vector" b
for (auto v1 : $1){
	for (auto v : v1){
		cout << v << " ";
	}
	cout << endl;
}
endsnippet


